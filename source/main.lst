gavrasm Gerd's AVR assembler version 5.4 (C)2022 by DG4FAC
----------------------------------------------------------
Source file: C:\Users\gondo\OneDrive\Desktop\CS\CS-278 Assembler\Final_Project_lovelace/source/main.asm
Hex file:    C:\Users\gondo\OneDrive\Desktop\CS\CS-278 Assembler\Final_Project_lovelace/source/main.hex
Eeprom file: C:\Users\gondo\OneDrive\Desktop\CS\CS-278 Assembler\Final_Project_lovelace/source/main.eep
Compiled:    17.12.2023, 15:33:39
Pass:        2
     1: ; compile with:
     2: ; gavrasm.exe -b main.asm
     3: ; 
     4: ; upload with:
     5: ; avrdude -c arduino -p atmega328p -P COM4 -U main.hex
     6: ;
     7: .DEVICE ATmega328p ;Define the correct device
     8: .EQU STACK_SRAM = $08FF ; Starting location of stack
     9: .EQU BUZZER_1 = $0100 ; Temp value for buzzer 1
    10: .EQU BUZZER_2 = $0101 ; Temp value for buzzer 2
    11: .EQU SCALE = $0102 ; For carrying the value of the current scale
    12: .EQU COUNTER_1 = $0103 ; For keeping offset for buzzer_1
    13: .EQU COUNTER_2 = $0104 ; For keeping offset for buzzer_2
    14: .EQU TICK_NEEDED = $0105 ; For keeping track of the preset tick amount before ending note
    15: .EQU TICK_CURRENT_1 = $0106 ; For keeping track of current tick count for buzzer 1
    16: .EQU TICK_CURRENT_2 = $107 ; For keeping track of current tick count for buzzer 2
    17: .EQU TIMER_OFFSET = $0108 ; The current offset for
    18: .EQU BUZZER_2_SIZE = $0109 ; Stores the size of Buzzer 2, for looping
    19: .EQU BUZZER_2_CURRENT = $010A ; Stores the current position in the loop for Buzzer 2
    20: .EQU BUZZER_2_OFFSETS = $010B ; Starting location for list of offsets for Buzzer 2
    21: .cseg
    22: .org 000000
    23: 000000   C03C  rjmp begin ; Reset vector
    24: 000001   0000  nop
    25: 000002   9518  reti ; INT0
    26: 000003   0000  nop
    27: 000004   9518  reti ; INT1
    28: 000005   0000  nop
    29: 000006   9518  reti ; PCI0
    30: 000007   0000  nop
    31: 000008   9518  reti ; PCI1
    32: 000009   0000  nop
    33: 00000A   9518  reti ; PCI2
    34: 00000B   0000  nop
    35: 00000C   9518  reti ; WDT
    36: 00000D   0000  nop
    37: 00000E   9518  reti ; OC2A
    38: 00000F   0000  nop
    39: 000010   9518  reti ; OC2B
    40: 000011   0000  nop
    41: 000012   9518  reti ; OVF2
    42: 000013   0000  nop
    43: 000014   9518  reti ; ICP1
    44: 000015   0000  nop
    45: 000016   9518  reti ; OC1A
    46: 000017   0000  nop
    47: 000018   9518  reti ; OC1B
    48: 000019   0000  nop
    49: 00001A   9518  reti ; OVF1
    50: 00001B   0000  nop
    51: 00001C   9518  reti ; OC0A
    52: 00001D   0000  nop
    53: 00001E   9518  reti ; OC0B
    54: 00001F   0000  nop
    55: 000020   9518  reti ; OVF0
    56: 000021   0000  nop
    57: 000022   9518  reti ; SPI
    58: 000023   0000  nop
    59: 000024   C00F  rjmp intr_urx ; URXC
    60: 000025   0000  nop
    61: 000026   9518  reti ; UDRE
    62: 000027   0000  nop
    63: 000028   9518  reti ; UTXC
    64: 000029   0000  nop
    65: 00002A   9518  reti ; ADCC
    66: 00002B   0000  nop
    67: 00002C   9518  reti ; ERDY
    68: 00002D   0000  nop
    69: 00002E   9518  reti ; ACI
    70: 00002F   0000  nop
    71: 000030   9518  reti ; TWI
    72: 000031   0000  nop
    73: 000032   9518  reti ; SPMR
    74: 000033   0000  nop
    75: intr_urx: ; interupt for receiving data through usart
    76: 000034   930F  push r16 ; store register
    77: 000035   9100  lds r16, UDR0 ; Load data received
        000036   00C6
    78: 000037   940E  call interpret_ascii ; loads counter or scale based on ascii value
        000038   00EC
    79: 000039   940E  call serial_send ; Send it back through USART
        00003A   00CB
    80: 00003B   910F  pop r16 ; restore register
    81: 00003C   9518  reti ;
    82: begin: ; the beginning
    83:     ; Setting stack pointer
    84: 00003D   E048  ldi r20, HIGH(STACK_SRAM) ; Set high part of stack pointer
    85: 00003E   BF4E  out SPH, r20 ;
    86: 00003F   EF4F  ldi r20, LOW(STACK_SRAM) ; Set low part of stack pointer
    87: 000040   BF4D  out SPL, r20 ;
    88: 	;
    89: 	; PortD, PortC and PortB set up
    90: 000041   E440  ldi r20, (1<<PD6) ; DDRD - data direction (PIN 6 output, PINS 7 and 0-5 input) OC0A is PORTD:6
    91: 000042   B94A  out DDRD, r20 ; Send configuration
    92: 000043   E048  ldi r20, (1<<PB3) ; DDRB - data direction (PIN 3 output, PINS 4-7 and 0-2 input) OC2A is PORTB:3
    93: 000044   B944  out DDRB, r20 ; Send configuration
    94: 000045   E040  ldi r20, $00 ; DDRC - data direction (all PINS input)
    95: 000046   B947  out DDRC, r20 ; Send configuration
    96: 	;
    97: 	; set up counter 0
    98: 	; set up change toggle on compare match COM0A1 and COM0A0
    99: 	; set up clear timer on compare match WGM01 and WGM00
   100: 000047   E442  ldi r20, (0<<COM0A1)|(1<<COM0A0)|(1<<WGM01)|(0<<WGM00) 
   101: 000048   BD44  out TCCR0A, r20 ; for counter 0
   102: 	; set up clock select for prescaler CS02, CS01, and CS00 to /256
   103: 000049   E044  ldi r20, (1<<CS02)|(0<<CS01)|(0<<CS00)
   104: 00004A   BD45  out TCCR0B, r20
   105: 	;
   106: 	; set up counter 2
   107: 	; set up change toggle on compare match COM2A1 and COM2A0
   108: 	; set up clear timer on compare match WGM21 and WGM20
   109: 00004B   E442  ldi r20, (0<<COM2A1)|(1<<COM2A0)|(1<<WGM21)|(0<<WGM20) 
   110: 00004C   9340  sts TCCR2A, r20 ; for counter 2
        00004D   00B0
   111: 	; set up clock select for prescaler CS22, CS21, and CS20 to /256
   112: 00004E   E046  ldi r20, (1<<CS22)|(1<<CS21)|(0<<CS20)
   113: 00004F   9340  sts TCCR2B, r20
        000050   00B1
   114: 	;
   115: 	; set up counter 1
   116: 000051   E04B  ldi r20, $03 | (1<<WGM12); Setting clock select to clk/128 from IO clock (16MHz >> ~16Khz) + WGM12 set high
   117: 000052   9340  sts TCCR1B, r20 ; write to Timer/Counter1 Control Register B
        000053   0081
   118: 	; speed for the opener
   119: 000054   E74D  ldi r20, $7D ; upper part of 16bit number
   120: 000055   9340  sts OCR1AH, r20 ; write upper first
        000056   0089
   121: 000057   E040  ldi r20, $00 ; lower part of 16bit number
   122: 000058   9340  sts OCR1AL, r20 ; write lower (and temp) second
        000059   0088
   123: 	; calls fun opening music
   124: 00005A   940E  call zelda_unlock_start
        00005B   0288
   125: 	; sets number of ticks needed to call the metronome function
   126: 00005C   E74F  ldi r20, $7F ; should call the needed function every 64 ticks
   127: 00005D   9340  sts TICK_NEEDED, r20
        00005E   0105
   128: 	; change length of notes for actual keyboard
   129: 00005F   E5E8  ldi ZL, LOW(TIMER_SPEED*2) ; load in address into Z
   130: 000060   E0F6  ldi ZH, HIGH(TIMER_SPEED*2)
   131: 000061   9145  lpm r20, Z+ ; upper part of 16bit number
   132: 000062   9340  sts OCR1AH, r20 ; write upper first
        000063   0089
   133: 000064   9144  lpm r20, Z ; lower part of 16bit number
   134: 000065   9340  sts OCR1AL, r20 ; write lower (and temp) second
        000066   0088
   135: 
   136: 	; clear counters and scale at reboot cause they save for some reason
   137: 000067   2744  clr r20
   138: 000068   9340  sts COUNTER_1, r20
        000069   0103
   139: 00006A   9340  sts COUNTER_2, r20
        00006B   0104
   140: 00006C   9340  sts SCALE, r20
        00006D   0102
   141: 00006E   9340  sts TICK_CURRENT_1, r20
        00006F   0106
   142: 000070   9340  sts TICK_CURRENT_2, r20
        000071   0107
   143: 000072   9340  sts BUZZER_2_SIZE, r20
        000073   0109
   144: 000074   9340  sts BUZZER_2_CURRENT, r20
        000075   010A
   145: 000076   9340  sts TIMER_OFFSET, r20
        000077   0108
   146: 	;
   147: 000078   940E  call usart_init ; initialize usart communication
        000079   00BA
   148: 	;
   149: 00007A   9478  sei ; turn on global interrupts
   150: motherloop: ; the loop where everything happens. Leave r19, r20, and r21 alone for note_check
   151: 	; note check
   152: 00007B   940E  call note_check ; compares r19, r20, and r21 to Scale, Counter 1, and Counter 2, changes notes and resets ticks if necessary
        00007C   0127
   153: 	; output to buzzer 1
   154: 00007D   9100  lds r16, BUZZER_1 ; load stored buzzer freq
        00007E   0100
   155: 00007F   BD07  out OCR0A, r16 ; send it
   156: 	; output to buzzer 2
   157: 000080   9100  lds r16, BUZZER_2 ; load stored buzzer freq
        000081   0101
   158: 000082   9300  sts OCR2A, r16 ; send it
        000083   00B3
   159: 000084   9BB1  sbis TIFR1, OCF1A ; skip if bit in Timer/Counter Interrupt Flag register is clear
   160: 000085   CFF5  rjmp motherloop
   161: 000086   9AB1  sbi TIFR1, OCF1A ; Set timer compare bit (should clear it)
   162: 000087   9100  lds r16, TICK_CURRENT_1 ; load tick for ending buzzer 1
        000088   0106
   163: 000089   9110  lds r17, TICK_NEEDED ; load in metronome 
        00008A   0105
   164: 00008B   1701  cp r16, r17 ; if we've reached enough ticks
   165: 00008C   F039  breq metronome_1 ; jump to clear counter_1
   166: motherloop_next:
   167: 00008D   9100  lds r16, TICK_CURRENT_2 ; load tick for transitioning buzzer 2
        00008E   0107
   168: 00008F   1701  cp r16, r17 ; if we've reached enough ticks
   169: 000090   F049  breq metronome_2 ; jump to transition counter_2
   170: motherloop_end:	
   171: 000091   940E  call next_tick ; moves the ticks of both counters forward 1
        000092   009D
   172: 000093   CFE7  rjmp motherloop ; heads back to begining
   173: ;
   174: metronome_1: ; called if the predetermined number of ticks have occurred
   175: 000094   930F  push r16 ; store
   176: 000095   2700  clr r16 ; insures it's cleared
   177: 000096   9300  sts COUNTER_1, r16 ; sets offset for buzzer 1 to $00
        000097   0103
   178: 000098   910F  pop r16 ; restore
   179: 000099   CFF3  rjmp motherloop_next ; head to next check
   180: ;
   181: metronome_2:
   182: 00009A   940E  call buzzer_2_loop ; moves counter 2 to next note in loop
        00009B   02FB
   183: 00009C   CFF4  rjmp motherloop_end ; jumps back to end
   184: next_tick: ; checks how many ticks have happened
   185: 00009D   930F  push r16 ; store
   186: 00009E   931F  push r17
   187: 00009F   9100  lds r16, TICK_CURRENT_1 ; how many ticks have occurred
        0000A0   0106
   188: 0000A1   9110  lds r17, TICK_NEEDED ; how many ticks before reset
        0000A2   0105
   189: 0000A3   9503  inc r16 ; increase
   190: 0000A4   1710  cp r17, r16 
   191: 0000A5   F060  brlo reset_tick_1 ; if we've reached the point to reset TICK_CURRENT_1 to 0
   192: 0000A6   9300  sts TICK_CURRENT_1, r16 ; store value increased by 1
        0000A7   0106
   193: next_tick_2:
   194: 0000A8   9100  lds r16, TICK_CURRENT_2 ; how many ticks have occurred
        0000A9   0107
   195: 0000AA   9503  inc r16 ; increase
   196: 0000AB   1710  cp r17, r16
   197: 0000AC   F048  brlo reset_tick_2 ; if we've reached the point to reset TICK_CURRENT_2 to 0
   198: 0000AD   9300  sts TICK_CURRENT_2, r16 ; store value increased by 1
        0000AE   0107
   199: end_tick:
   200: 0000AF   911F  pop r17
   201: 0000B0   910F  pop r16 ; restore
   202: 0000B1   9508  ret
   203: reset_tick_1: 
   204: 0000B2   2700  clr r16
   205: 0000B3   9300  sts TICK_CURRENT_1, r16 ; reset to 0
        0000B4   0106
   206: 0000B5   CFF2  rjmp next_tick_2
   207: reset_tick_2: 
   208: 0000B6   2700  clr r16
   209: 0000B7   9300  sts TICK_CURRENT_2, r16 ; reset to 0
        0000B8   0107
   210: 0000B9   CFF5  rjmp end_tick
   211: ;
   212: usart_init: ; initializes contact with usart
   213: 0000BA   930F  push r16 ; store registers
   214: 0000BB   931F  push r17 ;
   215:     ; Set baud rate
   216: 0000BC   E010  ldi r17, $00 ; High baud (aiming for 9600bps)
   217: 0000BD   E607  ldi r16, $67 ; Low baud
   218: 0000BE   9310  sts UBRR0H, r17
        0000BF   00C5
   219: 0000C0   9300  sts UBRR0L, r16
        0000C1   00C4
   220:     ; Enable receiver and transmitter
   221: 0000C2   E908  ldi r16, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
   222: 0000C3   9300  sts UCSR0B, r16
        0000C4   00C1
   223:     ; Set frame format: 8data, 2stop bit
   224: 0000C5   E00E  ldi r16, (1<<USBS0)|(3<<UCSZ00)
   225: 0000C6   9300  sts UCSR0C, r16
        0000C7   00C2
   226: 0000C8   911F  pop r17 ; restore register
   227: 0000C9   910F  pop r16
   228: 0000CA   9508  ret ;
   229: ; initializes sending the data back
   230: serial_send: ; passes in r16, sends it through USART
   231: 0000CB   931F  push r17 ; store register
   232: ; loop that continues until the data is sent back
   233: serial_send_loop: ;
   234: 0000CC   9110  lds r17, UCSR0A ; pulls in status
        0000CD   00C0
   235: 0000CE   FF15  sbrs r17, UDRE0 ; checks flag
   236: 0000CF   CFFC  rjmp serial_send_loop ; loop
   237: 0000D0   9300  sts UDR0, r16; sends data in r16
        0000D1   00C6
   238: 0000D2   911F  pop r17 ; restore register
   239: 0000D3   9508  ret
   240: ;	
   241: ; interprets ascii value received
   242: increase_length: ; increases length of each note
   243: 0000D4   9120  lds r18, TIMER_OFFSET ; load in current offset value
        0000D5   0108
   244: 0000D6   9523  inc r18 ; increase by 2
   245: 0000D7   9523  inc r18
   246: 0000D8   702F  andi r18, $0F ; clear up nibble
   247: 0000D9   9320  sts TIMER_OFFSET, r18 ; load in
        0000DA   0108
   248: 0000DB   940E  call change_speed ; call function that changes speed
        0000DC   02AE
   249: 0000DD   C02C  rjmp interpret_ascii_done ; finished
   250: decrease_length: ; decreases legnth of each note
   251: 0000DE   9120  lds r18, TIMER_OFFSET ; load in current offset value
        0000DF   0108
   252: 0000E0   952A  dec r18 ; decrease by 2
   253: 0000E1   952A  dec r18
   254: 0000E2   702F  andi r18, $0F ; clear up nibble
   255: 0000E3   9320  sts TIMER_OFFSET, r18 ; load in
        0000E4   0108
   256: 0000E5   940E  call change_speed ; call function that changes speed
        0000E6   02AE
   257: 0000E7   C022  rjmp interpret_ascii_done ; finished
   258: space_bar:
   259: 0000E8   2722  clr r18 ; set it to $00
   260: 0000E9   940E  call buzzer_2_storage ; stores cleared value in buzzer_2_loop of offsets
        0000EA   02C8
   261: 0000EB   C01E  rjmp interpret_ascii_done	
   262: interpret_ascii: ; pass in r16 and compare against expected ascii values
   263: 0000EC   931F  push r17 ; store
   264: 0000ED   93EF  push ZL
   265: 0000EE   93FF  push ZH
   266: 0000EF   932F  push r18
   267: 0000F0   933F  push r19
   268: 0000F1   2733  clr r19
   269: 0000F2   2F10  mov r17, r16 ; copy so r16 is not effected
   270: 0000F3   321B  cpi r17, '+'
   271: 0000F4   F2F9  breq increase_length ; for increasing timer 1 compare
   272: 0000F5   321D  cpi r17, '-'
   273: 0000F6   F339  breq decrease_length ; for decreasing timer 1 compare
   274: 0000F7   3210  cpi r17, $20
   275: 0000F8   F379  breq space_bar ; for adding cleared offset to buzzer 2 loop
   276: 0000F9   371B  cpi r17, 'z' +1
   277: 0000FA   F470  brsh outside_range
   278: 0000FB   3310  cpi r17, '0'
   279: 0000FC   F060  brlo outside_range
   280: 0000FD   3610  cpi r17, $60
   281: 0000FE   F488  brsh lower_case_ascii ; for buzzer 1 values and clear
   282: 0000FF   351B  cpi r17, 'Z'+1
   283: 000100   F440  brsh outside_range
   284: 000101   3411  cpi r17, 'A'
   285: 000102   F4D8  brsh upper_case_ascii ; for buzzer 2 values
   286: 000103   331A  cpi r17, '9' +1
   287: 000104   F420  brsh outside_range 
   288: 000105   5310  subi r17, '0' ; so that r17 is 0-9
   289: 000106   9310  sts SCALE, r17 ; stores that value in current scale
        000107   0102
   290: 000108   C001  rjmp interpret_ascii_done
   291: outside_range: ; if a value outside of the expected range was given
   292: 000109   E000  ldi r16, $00 
   293: interpret_ascii_done: ; when complete
   294: 00010A   913F  pop r19
   295: 00010B   912F  pop r18
   296: 00010C   91FF  pop ZH
   297: 00010D   91EF  pop ZL
   298: 00010E   911F  pop r17 ; restore
   299: 00010F   9508  ret
   300: lower_case_ascii: ; clear or buzzer 1
   301: 000110   3610  cpi r17, $60 ; if the value is '`'
   302: 000111   F049  breq special_clear_ascii
   303: 000112   5611  subi r17, 'a' ; so that 'a' is 0 and 'z' is 25
   304: 000113   E3EE  ldi ZL, LOW(OFFSET_LETTER_VALUE*2) ; load in address into Z
   305: 000114   E0F6  ldi ZH, HIGH(OFFSET_LETTER_VALUE*2)
   306: 000115   0FE1  add ZL, r17 ; move z pointer to offset
   307: 000116   1FF3  adc ZH, r19 ; deal with overflow if memory is on an 8 bit edge
   308: 000117   9124  lpm r18, Z ; load value of offset for counter from library
   309: 000118   9320  sts COUNTER_1, r18
        000119   0103
   310: 00011A   CFEF  rjmp interpret_ascii_done
   311: special_clear_ascii: ; clears both counters, silencing both buzzers
   312: 00011B   940E  call clear_buzzers
        00011C   02DE
   313: 00011D   CFEC  rjmp interpret_ascii_done	
   314: upper_case_ascii: ; effects only buzzer 2
   315: 00011E   5411  subi r17, 'A' ; so that 'A' is 0 and 'Z' is 25
   316: 00011F   E3EE  ldi ZL, LOW(OFFSET_LETTER_VALUE*2) ; load in address into Z
   317: 000120   E0F6  ldi ZH, HIGH(OFFSET_LETTER_VALUE*2)
   318: 000121   0FE1  add ZL, r17 ; move z pointer to offset
   319: 000122   1FF3  adc ZH, r19 ; deal with overflow if memory is on an 8 bit edge
   320: 000123   9124  LPM r18, Z ; load value of offset for counter from library
   321: 000124   940E  call buzzer_2_storage ; stores the value in a SRAM location for a loop for Buzzer 2
        000125   02C8
   322: 000126   CFE3  rjmp interpret_ascii_done
   323: ;
   324: note_check: ; pass in r19 (last scale), r20 (last counter_1), and r21 (last counter_2)
   325: 000127   930F  push r16 ; store
   326: 000128   931F  push r17
   327: 000129   932F  push r18
   328: 00012A   9100  lds r16, SCALE ; loads scale position
        00012B   0102
   329: 00012C   9110  lds r17, COUNTER_1 ; loads buzzer 1 value
        00012D   0103
   330: 00012E   9120  lds r18, COUNTER_2 ; loads buzzer 2 value
        00012F   0104
   331: 000130   1314  cpse r17, r20 ; compares previous buzzer 1 to current
   332: 000131   940E  call note_change_1
        000132   013D
   333: 000133   1325  cpse r18, r21 ; compares previous buzzer 2 to current
   334: 000134   940E  call note_change
        000135   0143
   335: 000136   1303  cpse r16, r19 ; compares previous scale position to current
   336: 000137   940E  call note_change
        000138   0143
   337: 000139   912F  pop r18
   338: 00013A   911F  pop r17
   339: 00013B   910F  pop r16 ; restore
   340: 00013C   9508  ret
   341: note_change_1:
   342: 00013D   930F  push r16 ; store
   343: 00013E   2700  clr r16 ; make sure it's clear
   344: 00013F   9300  sts TICK_CURRENT_1, r16 ; reset buzzer 1 tick counter
        000140   0106
   345: 000141   910F  pop r16
   346: 000142   C000  rjmp note_change ; continue
   347: note_change:
   348: 000143   936F  push r22 ; store
   349: 000144   9360  sts TCNT1H, r22 ; resets counter for timer 1
        000145   0085
   350: 000146   9360  sts TCNT1L, r22
        000147   0084
   351: 000148   2F30  mov r19, r16 ; loads new positions into old
   352: 000149   2F41  mov r20, r17
   353: 00014A   2F52  mov r21, r18
   354: 00014B   1306  cpse r16, r22; begin checking scales
   355: 00014C   C003  rjmp change_1 ; jump to the next
   356: 00014D   940E  call scale_0 ; change the notes according to this scale
        00014E   0184
   357: 00014F   C032  rjmp note_change_done ; jump to the end
   358: change_1:
   359: 000150   9563  inc r22
   360: 000151   1306  cpse r16, r22 ;
   361: 000152   C003  rjmp change_2 ; jump to the next
   362: 000153   940E  call scale_1 ; change the notes according to this scale
        000154   01C5
   363: 000155   C02C  rjmp note_change_done ; jump to the end
   364: change_2:
   365: 000156   9563  inc r22
   366: 000157   1306  cpse r16, r22 ;
   367: 000158   C003  rjmp change_3 ; jump to the next
   368: 000159   940E  call scale_2 ; change the notes according to this scale
        00015A   01B8
   369: 00015B   C026  rjmp note_change_done ; jump to the end
   370: change_3:
   371: 00015C   9563  inc r22
   372: 00015D   1306  cpse r16, r22 ;
   373: 00015E   C003  rjmp change_4 ; jump to the next
   374: 00015F   940E  call scale_3 ; change the notes according to this scale
        000160   01DF
   375: 000161   C020  rjmp note_change_done ; jump to the end
   376: change_4:
   377: 000162   9563  inc r22
   378: 000163   1306  cpse r16, r22 ;
   379: 000164   C003  rjmp change_5 ; jump to the next
   380: 000165   940E  call scale_4 ; change the notes according to this scale
        000166   01EC
   381: 000167   C01A  rjmp note_change_done ; jump to the end
   382: change_5:
   383: 000168   9563  inc r22
   384: 000169   1306  cpse r16, r22 ;
   385: 00016A   C003  rjmp change_6 ; jump to the next
   386: 00016B   940E  call scale_5 ; change the notes according to this scale
        00016C   01D2
   387: 00016D   C014  rjmp note_change_done ; jump to the end
   388: change_6:
   389: 00016E   9563  inc r22
   390: 00016F   1306  cpse r16, r22 ;
   391: 000170   C003  rjmp change_7 ; jump to the next
   392: 000171   940E  call scale_6 ; change the notes according to this scale
        000172   0191
   393: 000173   C00E  rjmp note_change_done ; jump to the end
   394: change_7:
   395: 000174   9563  inc r22
   396: 000175   1306  cpse r16, r22 ;
   397: 000176   C003  rjmp change_8 ; jump to the next
   398: 000177   940E  call scale_7 ; change the notes according to this scale
        000178   019E
   399: 000179   C008  rjmp note_change_done ; jump to the end
   400: change_8:
   401: 00017A   9563  inc r22
   402: 00017B   1306  cpse r16, r22 ;
   403: 00017C   C003  rjmp change_9 ; jump to the next
   404: 00017D   940E  call scale_8 ; change the notes according to this scale
        00017E   01AB
   405: 00017F   C002  rjmp note_change_done ; jump to the end
   406: change_9:
   407: 000180   940E  call scale_9 ; change the notes according to this scale
        000181   01F9
   408: note_change_done: ; complete changes
   409: 000182   916F  pop r22
   410: 000183   9508  ret
   411: scale_0: ; carry in r20 (counter_1) and r21 (counter_2)
   412: 000184   933F  push r19
   413: 000185   2F34  mov r19, r20 ; load counter in
   414: 000186   940E  call major_c_notes ; 
        000187   0213
   415: 000188   9330  sts BUZZER_1, r19 ; store new note
        000189   0100
   416: 00018A   2F35  mov r19, r21 ; load counter in
   417: 00018B   940E  call major_c_notes ;
        00018C   0213
   418: 00018D   9330  sts BUZZER_2, r19 ; store new note
        00018E   0101
   419: 00018F   913F  pop r19
   420: 000190   9508  ret
   421: scale_6: ; carry in r20 (counter_1) and r21 (counter_2)
   422: 000191   933F  push r19
   423: 000192   2F34  mov r19, r20 ; load counter in
   424: 000193   940E  call pentatonic_c_notes ; 
        000194   023A
   425: 000195   9330  sts BUZZER_1, r19 ; store new note
        000196   0100
   426: 000197   2F35  mov r19, r21 ; load counter in
   427: 000198   940E  call pentatonic_c_notes ;
        000199   023A
   428: 00019A   9330  sts BUZZER_2, r19 ; store new note
        00019B   0101
   429: 00019C   913F  pop r19
   430: 00019D   9508  ret
   431: scale_7: ; carry in r20 (counter_1) and r21 (counter_2)
   432: 00019E   933F  push r19
   433: 00019F   2F34  mov r19, r20 ; load counter in
   434: 0001A0   940E  call pentatonic_b_notes ; 
        0001A1   022D
   435: 0001A2   9330  sts BUZZER_1, r19 ; store new note
        0001A3   0100
   436: 0001A4   2F35  mov r19, r21 ; load counter in
   437: 0001A5   940E  call pentatonic_b_notes ;
        0001A6   022D
   438: 0001A7   9330  sts BUZZER_2, r19 ; store new note
        0001A8   0101
   439: 0001A9   913F  pop r19
   440: 0001AA   9508  ret
   441: scale_8: ; carry in r20 (counter_1) and r21 (counter_2)
   442: 0001AB   933F  push r19
   443: 0001AC   2F34  mov r19, r20 ; load counter in
   444: 0001AD   940E  call blues_c_notes ; 
        0001AE   0206
   445: 0001AF   9330  sts BUZZER_1, r19 ; store new note
        0001B0   0100
   446: 0001B1   2F35  mov r19, r21 ; load counter in
   447: 0001B2   940E  call blues_c_notes ;
        0001B3   0206
   448: 0001B4   9330  sts BUZZER_2, r19 ; store new note
        0001B5   0101
   449: 0001B6   913F  pop r19
   450: 0001B7   9508  ret
   451: scale_2: ; carry in r20 (counter_1) and r21 (counter_2)
   452: 0001B8   933F  push r19
   453: 0001B9   2F34  mov r19, r20 ; load counter in
   454: 0001BA   940E  call minor_c_notes ; 
        0001BB   0220
   455: 0001BC   9330  sts BUZZER_1, r19 ; store new note
        0001BD   0100
   456: 0001BE   2F35  mov r19, r21 ; load counter in
   457: 0001BF   940E  call minor_c_notes ;
        0001C0   0220
   458: 0001C1   9330  sts BUZZER_2, r19 ; store new note
        0001C2   0101
   459: 0001C3   913F  pop r19
   460: 0001C4   9508  ret
   461: scale_1: ; carry in r20 (counter_1) and r21 (counter_2)
   462: 0001C5   933F  push r19
   463: 0001C6   2F34  mov r19, r20 ; load counter in
   464: 0001C7   940E  call harmonic_minor_c_notes ; 
        0001C8   0247
   465: 0001C9   9330  sts BUZZER_1, r19 ; store new note
        0001CA   0100
   466: 0001CB   2F35  mov r19, r21 ; load counter in
   467: 0001CC   940E  call  harmonic_minor_c_notes;
        0001CD   0247
   468: 0001CE   9330  sts BUZZER_2, r19 ; store new note
        0001CF   0101
   469: 0001D0   913F  pop r19
   470: 0001D1   9508  ret
   471: scale_5: ; carry in r20 (counter_1) and r21 (counter_2)
   472: 0001D2   933F  push r19
   473: 0001D3   2F34  mov r19, r20 ; load counter in
   474: 0001D4   940E  call major_bebop_c_notes; 
        0001D5   0261
   475: 0001D6   9330  sts BUZZER_1, r19 ; store new note
        0001D7   0100
   476: 0001D8   2F35  mov r19, r21 ; load counter in
   477: 0001D9   940E  call major_bebop_c_notes;
        0001DA   0261
   478: 0001DB   9330  sts BUZZER_2, r19 ; store new note
        0001DC   0101
   479: 0001DD   913F  pop r19
   480: 0001DE   9508  ret
   481: scale_3: ; carry in r20 (counter_1) and r21 (counter_2)
   482: 0001DF   933F  push r19
   483: 0001E0   2F34  mov r19, r20 ; load counter in
   484: 0001E1   940E  call aeolian_dominant_c_notes; 
        0001E2   026E
   485: 0001E3   9330  sts BUZZER_1, r19 ; store new note
        0001E4   0100
   486: 0001E5   2F35  mov r19, r21 ; load counter in
   487: 0001E6   940E  call aeolian_dominant_c_notes;
        0001E7   026E
   488: 0001E8   9330  sts BUZZER_2, r19 ; store new note
        0001E9   0101
   489: 0001EA   913F  pop r19
   490: 0001EB   9508  ret
   491: scale_4: ; carry in r20 (counter_1) and r21 (counter_2)
   492: 0001EC   933F  push r19
   493: 0001ED   2F34  mov r19, r20 ; load counter in
   494: 0001EE   940E  call phyrgian_dominant_c_notes ; 
        0001EF   027B
   495: 0001F0   9330  sts BUZZER_1, r19 ; store new note
        0001F1   0100
   496: 0001F2   2F35  mov r19, r21 ; load counter in
   497: 0001F3   940E  call phyrgian_dominant_c_notes ;
        0001F4   027B
   498: 0001F5   9330  sts BUZZER_2, r19 ; store new note
        0001F6   0101
   499: 0001F7   913F  pop r19
   500: 0001F8   9508  ret
   501: scale_9: ; carry in r20 (counter_1) and r21 (counter_2)
   502: 0001F9   933F  push r19
   503: 0001FA   2F34  mov r19, r20 ; load counter in
   504: 0001FB   940E  call chromatic_notes; 
        0001FC   0254
   505: 0001FD   9330  sts BUZZER_1, r19 ; store new note
        0001FE   0100
   506: 0001FF   2F35  mov r19, r21 ; load counter in
   507: 000200   940E  call chromatic_notes;
        000201   0254
   508: 000202   9330  sts BUZZER_2, r19 ; store new note
        000203   0101
   509: 000204   913F  pop r19
   510: 000205   9508  ret
   511: blues_c_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   512: 000206   93EF  push ZL ; Store registers
   513: 000207   93FF  push ZH
   514: 000208   931F  push r17
   515: 000209   2711  clr r17
   516: 00020A   EEEA  ldi ZL, LOW(BLUES_SCALE_C*2) ; Load in address into Z
   517: 00020B   E0F6  ldi ZH, HIGH(BLUES_SCALE_C*2)
   518: 00020C   0FE3  add ZL, r19 ; Move Z pointer to offset
   519: 00020D   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   520: 00020E   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   521: 00020F   911F  pop r17
   522: 000210   91FF  pop ZH ; Restore registers
   523: 000211   91EF  pop ZL
   524: 000212   9508  ret ; Return
   525: major_c_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   526: 000213   93EF  push ZL ; Store registers
   527: 000214   93FF  push ZH
   528: 000215   931F  push r17
   529: 000216   2711  clr r17
   530: 000217   EBE2  ldi ZL, LOW(MAJOR_SCALE_C*2) ; Load in address into Z
   531: 000218   E0F6  ldi ZH, HIGH(MAJOR_SCALE_C*2)
   532: 000219   0FE3  add ZL, r19 ; Move Z pointer to offset
   533: 00021A   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   534: 00021B   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   535: 00021C   911F  pop r17
   536: 00021D   91FF  pop ZH ; Restore registers
   537: 00021E   91EF  pop ZL
   538: 00021F   9508  ret ; Return
   539: minor_c_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   540: 000220   93EF  push ZL ; Store registers
   541: 000221   93FF  push ZH
   542: 000222   931F  push r17
   543: 000223   2711  clr r17
   544: 000224   ECEE  ldi ZL, LOW(MINOR_SCALE_C*2) ; Load in address into Z
   545: 000225   E0F6  ldi ZH, HIGH(MINOR_SCALE_C*2)
   546: 000226   0FE3  add ZL, r19 ; Move Z pointer to offset
   547: 000227   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   548: 000228   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   549: 000229   911F  pop r17
   550: 00022A   91FF  pop ZH ; Restore registers
   551: 00022B   91EF  pop ZL
   552: 00022C   9508  ret ; Return
   553: pentatonic_b_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   554: 00022D   93EF  push ZL ; Store registers
   555: 00022E   93FF  push ZH
   556: 00022F   931F  push r17
   557: 000230   2711  clr r17
   558: 000231   E7EA  ldi ZL, LOW(PENTATONIC_SCALE_B*2) ; Load in address into Z
   559: 000232   E0F6  ldi ZH, HIGH(PENTATONIC_SCALE_B*2)
   560: 000233   0FE3  add ZL, r19 ; Move Z pointer to offset
   561: 000234   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   562: 000235   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   563: 000236   911F  pop r17
   564: 000237   91FF  pop ZH ; Restore registers
   565: 000238   91EF  pop ZL
   566: 000239   9508  ret ; Return
   567: pentatonic_c_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   568: 00023A   93EF  push ZL ; Store registers
   569: 00023B   93FF  push ZH
   570: 00023C   931F  push r17
   571: 00023D   2711  clr r17
   572: 00023E   E9E6  ldi ZL, LOW(PENTATONIC_SCALE_C*2) ; Load in address into Z
   573: 00023F   E0F6  ldi ZH, HIGH(PENTATONIC_SCALE_C*2)
   574: 000240   0FE3  add ZL, r19 ; Move Z pointer to offset
   575: 000241   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   576: 000242   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   577: 000243   911F  pop r17
   578: 000244   91FF  pop ZH ; Restore registers
   579: 000245   91EF  pop ZL
   580: 000246   9508  ret ; Return
   581: harmonic_minor_c_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   582: 000247   93EF  push ZL ; Store registers
   583: 000248   93FF  push ZH
   584: 000249   931F  push r17
   585: 00024A   2711  clr r17
   586: 00024B   E0E6  ldi ZL, LOW(HARMONIC_MINOR_SCALE_C*2) ; Load in address into Z
   587: 00024C   E0F7  ldi ZH, HIGH(HARMONIC_MINOR_SCALE_C*2)
   588: 00024D   0FE3  add ZL, r19 ; Move Z pointer to offset
   589: 00024E   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   590: 00024F   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   591: 000250   911F  pop r17
   592: 000251   91FF  pop ZH ; Restore registers
   593: 000252   91EF  pop ZL
   594: 000253   9508  ret ; Return
   595: chromatic_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   596: 000254   93EF  push ZL ; Store registers
   597: 000255   93FF  push ZH
   598: 000256   931F  push r17
   599: 000257   2711  clr r17
   600: 000258   E2E2  ldi ZL, LOW(CHROMATIC_SCALE*2) ; Load in address into Z
   601: 000259   E0F7  ldi ZH, HIGH(CHROMATIC_SCALE*2)
   602: 00025A   0FE3  add ZL, r19 ; Move Z pointer to offset
   603: 00025B   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   604: 00025C   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   605: 00025D   911F  pop r17
   606: 00025E   91FF  pop ZH ; Restore registers
   607: 00025F   91EF  pop ZL
   608: 000260   9508  ret ; Return
   609: major_bebop_c_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   610: 000261   93EF  push ZL ; Store registers
   611: 000262   93FF  push ZH
   612: 000263   931F  push r17
   613: 000264   2711  clr r17
   614: 000265   E3EE  ldi ZL, LOW(MAJOR_BEBOP_C*2) ; Load in address into Z
   615: 000266   E0F7  ldi ZH, HIGH(MAJOR_BEBOP_C*2)
   616: 000267   0FE3  add ZL, r19 ; Move Z pointer to offset
   617: 000268   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   618: 000269   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   619: 00026A   911F  pop r17
   620: 00026B   91FF  pop ZH ; Restore registers
   621: 00026C   91EF  pop ZL
   622: 00026D   9508  ret ; Return
   623: aeolian_dominant_c_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   624: 00026E   93EF  push ZL ; Store registers
   625: 00026F   93FF  push ZH
   626: 000270   931F  push r17
   627: 000271   2711  clr r17
   628: 000272   E5EA  ldi ZL, LOW(AEOLIAN_DOMINANT_C*2) ; Load in address into Z
   629: 000273   E0F7  ldi ZH, HIGH(AEOLIAN_DOMINANT_C*2)
   630: 000274   0FE3  add ZL, r19 ; Move Z pointer to offset
   631: 000275   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   632: 000276   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   633: 000277   911F  pop r17
   634: 000278   91FF  pop ZH ; Restore registers
   635: 000279   91EF  pop ZL
   636: 00027A   9508  ret ; Return
   637: phyrgian_dominant_c_notes: ; carry in r19, which should hold counter_1 or counter_2 value
   638: 00027B   93EF  push ZL ; Store registers
   639: 00027C   93FF  push ZH
   640: 00027D   931F  push r17
   641: 00027E   2711  clr r17
   642: 00027F   E7E6  ldi ZL, LOW(PHRYGIAN_DOMINANT_C*2) ; Load in address into X
   643: 000280   E0F7  ldi ZH, HIGH(PHRYGIAN_DOMINANT_C*2)
   644: 000281   0FE3  add ZL, r19 ; Move X pointer to offset
   645: 000282   1FF1  adc ZH, r17 ; Deal with overflow if memory is on an 8 bit edge
   646: 000283   9134  lpm r19, Z ; Load value from SRAM and carry out through r19
   647: 000284   911F  pop r17
   648: 000285   91FF  pop ZH ; Restore registers
   649: 000286   91EF  pop ZL
   650: 000287   9508  ret ; Return
   651: zelda_unlock_start:
   652: 000288   93EF  push ZL ; Store registers
   653: 000289   93FF  push ZH
   654: 00028A   930F  push r16
   655: 00028B   931F  push r17
   656: 00028C   932F  push r18
   657: 00028D   933F  push r19
   658: 00028E   934F  push r20
   659: 00028F   E049  ldi r20, $09 ; for jumping the octave
   660: 000290   2711  clr r17 ; for adc
   661: 000291   2700  clr r16 ; cleared for counter
   662: zelda_unlock:
   663: 000292   0000  nop ; No op, pause / wait
   664: 000293   9BB1  sbis TIFR1, OCF1A ; skip if bit in Timer/Counter Interrupt Flag register is set
   665: 	; TIFR1 - Timer/Counter1 Interrupt Flag Register
   666: 	; OCF1A - Timer/Counter1, Output Compare A Match Flag
   667: 000294   CFFD  rjmp zelda_unlock ; loop back up continuously
   668: 000295   0000  nop ; OCF1A Bit is set (this means counter has reached compare value)
   669: 000296   9AB1  sbi TIFR1, OCF1A ; Set timer compare bit (should clear it)
   670: 000297   3008  cpi r16, $08 ; if the final note has played
   671: 000298   F069  breq zelda_unlock_end
   672: 000299   E6E8  ldi ZL, LOW(ZELDA_UNLOCK_NOTES*2) ; load in address into Z
   673: 00029A   E0F6  ldi ZH, HIGH(ZELDA_UNLOCK_NOTES*2)
   674: 00029B   0FE0  add ZL, r16
   675: 00029C   1FF1  adc ZH, r17
   676: 00029D   9503  inc r16
   677: 00029E   9124  lpm r18, Z
   678: 00029F   0FE4  add ZL, r20 ; jump the octave
   679: 0002A0   1FF1  adc ZH, r17
   680: 0002A1   9134  lpm r19, Z ; Load value from SRAM
   681: 0002A2   BD27  out OCR0A, r18
   682: 0002A3   9330  sts OCR2A, r19
        0002A4   00B3
   683: 0002A5   CFEC  rjmp zelda_unlock
   684: zelda_unlock_end:
   685: 0002A6   914F  pop r20
   686: 0002A7   913F  pop r19
   687: 0002A8   912F  pop r18
   688: 0002A9   911F  pop r17
   689: 0002AA   910F  pop r16
   690: 0002AB   91FF  pop ZH ; Restore registers
   691: 0002AC   91EF  pop ZL
   692: 0002AD   9508  ret
   693: change_speed:
   694: 0002AE   930F  push r16 ; store
   695: 0002AF   931F  push r17
   696: 0002B0   932F  push r18
   697: 0002B1   933F  push r19
   698: 0002B2   93EF  push ZL
   699: 0002B3   93FF  push ZH
   700: 0002B4   2733  clr r19 ; make sure it's actually clear
   701: 0002B5   E5E8  ldi ZL, LOW(TIMER_SPEED*2) ; Load in address into Z
   702: 0002B6   E0F6  ldi ZH, HIGH(TIMER_SPEED*2)
   703: 0002B7   9100  lds r16, TIMER_OFFSET ; load offset for speed
        0002B8   0108
   704: 0002B9   0FE0  add ZL, r16 ; move pointer of Z
   705: 0002BA   1FF3  adc ZH, r19
   706: 0002BB   9115  lpm r17, Z+ ; load first half of speed
   707: 0002BC   9124  lpm r18, Z ; load second half of speed
   708: 0002BD   9310  sts OCR1AH, r17
        0002BE   0089
   709: 0002BF   9320  sts OCR1AL, r18
        0002C0   0088
   710: 0002C1   91FF  pop ZH
   711: 0002C2   91EF  pop ZL
   712: 0002C3   913F  pop r19
   713: 0002C4   912F  pop r18
   714: 0002C5   911F  pop r17
   715: 0002C6   910F  pop r16 ; restore
   716: 0002C7   9508  ret
   717: buzzer_2_storage: ; carry in r18 from upper_case_ascii
   718: 0002C8   930F  push r16 ; store
   719: 0002C9   931F  push r17
   720: 0002CA   93AF  push XL
   721: 0002CB   93BF  push XH
   722: 0002CC   2711  clr r17 ; verify is clear
   723: 0002CD   9100  lds r16, BUZZER_2_SIZE ; load in size of loop
        0002CE   0109
   724: 0002CF   3F0F  cpi r16, $FF ; doesn't load if buzzer if its full
   725: 0002D0   F041  breq buzzer_2_end ; jump to end
   726: 0002D1   E0AB  ldi XL, LOW(BUZZER_2_OFFSETS)
   727: 0002D2   E0B1  ldi XH, HIGH(BUZZER_2_OFFSETS)
   728: 0002D3   0FA0  add XL, r16
   729: 0002D4   1FB1  adc XH, r17 ; move to the next open space for SRAM storage
   730: 0002D5   932C  st X, r18 ; stores the passed in offset into the SRAM location
   731: 0002D6   9503  inc r16
   732: 0002D7   9300  sts BUZZER_2_SIZE, r16 ; increase the loop by 1 for the new note
        0002D8   0109
   733: buzzer_2_end:	
   734: 0002D9   91BF  pop XH
   735: 0002DA   91AF  pop XL
   736: 0002DB   911F  pop r17
   737: 0002DC   910F  pop r16 ; restore
   738: 0002DD   9508  ret
   739: clear_buzzers: ; for killing buzzer 1 and clearing buzzer 2 loop
   740: 0002DE   931F  push r17 ; store
   741: 0002DF   932F  push r18
   742: 0002E0   93BF  push XH
   743: 0002E1   93AF  push XL
   744: 0002E2   2711  clr r17 ; insure it's actually clear
   745: 0002E3   9310  sts COUNTER_1, r17 ; kill buzzer_1
        0002E4   0103
   746: 0002E5   9310  sts COUNTER_2, r17
        0002E6   0104
   747: 0002E7   9310  sts BUZZER_2_CURRENT, r17 ; reset position for Buzzer_2_loop
        0002E8   010A
   748: clear_buzzer_2_loop: ; while loop for clearing buzzer 2 offsets and resetting size of loop to 0
   749: 0002E9   9120  lds r18, BUZZER_2_SIZE ; loads current size
        0002EA   0109
   750: 0002EB   3020  cpi r18, $00 ; if buzzer 2 size was already zero then it's already cleared
   751: 0002EC   F049  breq clear_buzzer_2_done
   752: 0002ED   E0AB  ldi XL, LOW(BUZZER_2_OFFSETS) ; loads location of buzzer_2_offsets
   753: 0002EE   E0B1  ldi XH, HIGH(BUZZER_2_OFFSETS)
   754: 0002EF   952A  dec r18 ; decreases because size should always be 1 more than actual size
   755: 0002F0   0FA2  add XL, r18 ; moves to end of loop of offsets
   756: 0002F1   0FB1  add XH, r17
   757: 0002F2   931C  st X, r17 ; clears the last note
   758: 0002F3   9320  sts BUZZER_2_SIZE, r18 ; set the new size
        0002F4   0109
   759: 0002F5   CFF3  rjmp clear_buzzer_2_loop
   760: clear_buzzer_2_done: ; time to finish	
   761: 0002F6   91AF  pop XL
   762: 0002F7   91BF  pop XH
   763: 0002F8   912F  pop r18
   764: 0002F9   911F  pop r17 ; restore
   765: 0002FA   9508  ret
   766: buzzer_2_loop: ; the loop for setting the offset for Counter_2
   767: 0002FB   930F  push r16 ; store
   768: 0002FC   931F  push r17
   769: 0002FD   932F  push r18
   770: 0002FE   933F  push r19
   771: 0002FF   93AF  push XL
   772: 000300   93BF  push XH
   773: 000301   2722  clr r18 ; insure it's actually cleared
   774: 000302   9100  lds r16, BUZZER_2_SIZE ; loads in size of loop
        000303   0109
   775: 000304   1702  cp r16, r18 ; if the size of the loop is $00, skip to end
   776: 000305   F071  breq buzzer_2_loop_end
   777: 000306   9110  lds r17, BUZZER_2_CURRENT ; loads in current position in loop
        000307   010A
   778: 000308   E0AB  ldi XL, LOW(BUZZER_2_OFFSETS)
   779: 000309   E0B1  ldi XH, HIGH(BUZZER_2_OFFSETS)
   780: 00030A   0FA1  add XL, r17 ; add current offset to X
   781: 00030B   1FB2  adc XH, r18
   782: 00030C   913C  ld r19, X ; load offset value stored in X
   783: 00030D   9330  sts COUNTER_2, r19 ; store it in counter_2
        00030E   0104
   784: 00030F   9513  inc r17 ; increment the counter
   785: 000310   1710  cp r17, r16 ; check to see if we've reached the end of the loop
   786: 000311   F049  breq buzzer_2_loop_reset
   787: 000312   9310  sts BUZZER_2_CURRENT, r17 ; store the counter
        000313   010A
   788: buzzer_2_loop_end:	
   789: 000314   91BF  pop XH
   790: 000315   91AF  pop XL
   791: 000316   913F  pop r19
   792: 000317   912F  pop r18
   793: 000318   911F  pop r17
   794: 000319   910F  pop r16 ; restore
   795: 00031A   9508  ret
   796: buzzer_2_loop_reset: ; resets counter to $00 to start loop from beginning
   797: 00031B   2711  clr r17
   798: 00031C   9310  sts BUZZER_2_CURRENT, r17 
        00031D   010A
   799: 00031E   CFF5  rjmp buzzer_2_loop_end	
   800: ; for simplifying assigning ascii values to the counters
   801: ; offset sent to counter a  b  c  d   e   f   g   h   i   j   k   l   m  n  o   p   q   r   s  t   u   v  w   x  y   z
   802: OFFSET_LETTER_VALUE: .db 8, 5, 3, 10, 19, 11, 12, 13, 24, 14, 15, 16, 7, 6, 25, 26, 17, 20, 9, 21, 23, 4, 18, 2, 22, 1
        00031F 0508 0A03 0B13 0D0C
        000323 0E18 100F 0607 1A19
        000327 1411 1509 0417 0212
        00032B 0116
   803: ;
   804: ; for speed of timer 1   64/sec    32/sec    16/sec    8/sec     4/sec     2/sec     256/sec   128/sec
   805: TIMER_SPEED: .db         $00, $FA, $01, $F4, $03, $E8, $07, $D0, $0F, $A0, $1F, $40, $00, $3E, $00, $7D
        00032C FA00 F401 E803 D007
        000330 A00F 401F 3E00 7D00
   806: ;
   807: ; library of pitches
   808: ; b2   c3   c#3  d3   d#3  e3   f3   f#3  g3   g#3  a3   a#3  b3   c4   c#4  d4   d#4  e4   f4   f#4  g4   g#4  a4   a#4  b4   c5
   809: ; $FD, $EE, $E1, $D4, $C8, $BD, $B2, $A8, $9F, $96, $8E, $86, $7E, $77, $70, $6A, $64, $5E, $59, $54, $4F, $4B, $47, $43, $3F, $3B
   810: ;
   811: ; c#5  d5   d#5  e5   f5   f#5  g5   g#5  a5   a#5  b5   c6   c#6  d6   d#6  e6   f6   f#6  g6   g#6  a6   a#6  b6   c7
   812: ; $38, $35, $32, $2F, $2C, $2A, $27, $25, $23, $21, $1F, $1D, $1C, $1A, $19, $17, $16, $15, $13, $12, $11, $10, $0F, $0E
   813: ;
   814: ;                       g4   f#4  d#4  a3   g#3  e4   g#4  c5   clr  g5   f#5  d#5  a4   g#4  e5   g#5  c6   clr
   815: ZELDA_UNLOCK_NOTES: .db $4F, $54, $64, $8E, $96, $5E, $4B, $3B, $00, $27, $2A, $32, $47, $4B, $2F, $25, $1D, $00
        000334 544F 8E64 5E96 3B4B
        000338 2700 322A 4B47 252F
        00033C 001D
   816: ;
   817: ;                       clr  b2   c#3  d#3  f#3  g#3  b3   c#4  d#4  f#4  g#4  b4   c#5  d#5  f#5  g#5  b5   c#6  d#6  f#6  g#6  b6   clr  clr  clr  clr  clr  clr
   818: PENTATONIC_SCALE_B: .db $00, $FD, $E1, $C8, $A8, $96, $7E, $70, $64, $54, $4B, $3F, $38, $32, $2A, $25, $1F, $1C, $19, $15, $12, $0F, $00, $00, $00, $00, $00, $00
        00033D FD00 C8E1 96A8 707E
        000341 5464 3F4B 3238 252A
        000345 1C1F 1519 0F12 0000
        000349 0000 0000
   819: ;
   820: ;                       clr  c3   d3   e3   g3   a3   c4   d4   e4   g4   a4   c7   d7   e7   g6   a6   c7   d7   e7   g7   a7   c8   clr  clr  clr  clr  clr  clr
   821: PENTATONIC_SCALE_C: .db $00, $EE, $D4, $BD, $9F, $8E, $77, $6A, $5E, $4F, $47, $3B, $35, $2F, $27, $23, $1D, $1A, $17, $13, $11, $0E, $00, $00, $00, $00, $00, $00
        00034B EE00 BDD4 8E9F 6A77
        00034F 4F5E 3B47 2F35 2327
        000353 1A1D 1317 0E11 0000
        000357 0000 0000
   822: ;
   823: ;                       clr  c3   d3   e3   f3   g3   a3   b3   c4   d4   e4   f4   g4   a4   b4   c5   d5   e5   f5   g5   a5   b5   c6   d6   e6   f6   g6   clr
   824: MAJOR_SCALE_C: .db      $00, $EE, $D4, $BD, $B2, $9F, $8E, $7E, $77, $6A, $5E, $59, $4F, $47, $3F, $3B, $35, $2F, $2C, $27, $23, $1F, $1D, $1A, $17, $16, $13, $00
        000359 EE00 BDD4 9FB2 7E8E
        00035D 6A77 595E 474F 3B3F
        000361 2F35 272C 1F23 1A1D
        000365 1617 0013
   825: ;
   826: ;                       clr  c3   d3   d#3  f3   g3   g#3  a#3  c4   d4   d#4  f4   g4   g#4  a#4  c5   d5   d#5  f5   g5   g#5  a#5  c6   d6   d#6  f6   g6   clr
   827: MINOR_SCALE_C: .db      $00, $EE, $D4, $C8, $B2, $9F, $96, $86, $77, $6A, $64, $59, $4F, $4B, $43, $3B, $35, $32, $2C, $27, $25, $21, $1D, $1A, $19, $16, $13, $00
        000367 EE00 C8D4 9FB2 8696
        00036B 6A77 5964 4B4F 3B43
        00036F 3235 272C 2125 1A1D
        000373 1619 0013
   828: ;
   829: ;                       clr  c3   d3   d#3  e3   g3   a3   c4   d4   d#4  e4   g4   a4   c5   d5   d#5  e5   g5   a5   c6   d6   d#6  e6   g6   a6   c7   clr  clr
   830: BLUES_SCALE_C: .db      $00, $EE, $D4, $C8, $BD, $9F, $8E, $77, $6A, $64, $5E, $4F, $47, $3B, $35, $32, $2F, $27, $23, $1D, $1A, $19, $17, $13, $11, $0E, $00, $00
        000375 EE00 C8D4 9FBD 778E
        000379 646A 4F5E 3B47 3235
        00037D 272F 1D23 191A 1317
        000381 0E11 0000
   831: ;
   832: ;                            clr  c3   d3   d#3  f3   g3   g#3  b3   c4   d4   d#4  f4   g4   g#4  b4   c5   d5   d#5  f5   g5   g#5  b5   c6   d6   d#6  f6   g6   clr
   833: HARMONIC_MINOR_SCALE_C: .db  $00, $EE, $D4, $C8, $B2, $9F, $96, $7E, $77, $6A, $64, $59, $4F, $4B, $3F, $3B, $35, $32, $2C, $27, $25, $1F, $1D, $1A, $19, $16, $13, $00
        000383 EE00 C8D4 9FB2 7E96
        000387 6A77 5964 4B4F 3B3F
        00038B 3235 272C 1F25 1A1D
        00038F 1619 0013
   834: ;
   835: ;                       clr  b2   c3   c#3  d3   d#3  e3   f3   f#3  g3   g#3  a3   a#3  b3   c4   c#4  d4   d#4  e4   f4   f#4  g4   g#4  a4   a#4  b4   c5   clr
   836: CHROMATIC_SCALE: .db    $00, $FD, $EE, $E1, $D4, $C8, $BD, $B2, $A8, $9F, $96, $8E, $86, $7E, $77, $70, $6A, $64, $5E, $59, $54, $4F, $4B, $47, $43, $3F, $3B, $00
        000391 FD00 E1EE C8D4 B2BD
        000395 9FA8 8E96 7E86 7077
        000399 646A 595E 4F54 474B
        00039D 3F43 003B
   837: ;
   838: ;						clr  c3   d3   e3   f3   g3   g#3  a3   b3   c4   d4   e4   f4   g4   g#4  a4   b4   c5   d5   e5   f5   g5   g#5  a5   b5   c6   d6   clr
   839: MAJOR_BEBOP_C: .db      $00, $EE, $D4, $BD, $B2, $9F, $96, $8E, $7E, $77, $6A, $5E, $59, $4F, $4B, $47, $3F, $3B, $35, $2F, $2C, $27, $25, $23, $1F, $1D, $1A, $00
        00039F EE00 BDD4 9FB2 8E96
        0003A3 777E 5E6A 4F59 474B
        0003A7 3B3F 2F35 272C 2325
        0003AB 1D1F 001A
   840: ;
   841: ;                       clr  c3   d3   e3   f3   g3   g#3  a#3  c4   d4   e4   f4   g4   g#4  a#4  c5   d5   e5   f5   g5   g#5  a#5  c6   d6   e6   f6   g6   clr
   842: AEOLIAN_DOMINANT_C: .db $00, $EE, $D4, $BD, $B2, $9F, $96, $86, $77, $6A, $5E, $59, $4F, $4B, $43, $3B, $35, $2F, $2C, $27, $25, $21, $1D, $1A, $17, $16, $13, $00
        0003AD EE00 BDD4 9FB2 8696
        0003B1 6A77 595E 4B4F 3B43
        0003B5 2F35 272C 2125 1A1D
        0003B9 1617 0013
   843: ;
   844: ;                            clr  c3   c#3  e3   f3   g3   g#3  a#3  c4   c#4  e4   f4   g4   g#4  a#4  c5   c#5  e5   f5   g5   g#5  a#5  c6   c#6  e6   f6   g6   clr
   845: PHRYGIAN_DOMINANT_C: .db     $00, $EE, $E1, $BD, $B2, $9F, $96, $86, $77, $70, $5E, $59, $4F, $4B, $43, $3B, $38, $2F, $2C, $27, $25, $21, $1D, $1C, $17, $16, $13, $00
        0003BB EE00 BDE1 9FB2 8696
        0003BF 7077 595E 4B4F 3B43
        0003C3 2F38 272C 2125 1C1D
        0003C7 1617 0013
   846: 
   847: 
   848: ; store Counter_2 values on a loop based of timer 1 that changes on regular intervals
   849: ; have some ascii values adjust OCR1AH and OCR1AL to change length of notes for Buzzer_1

Program             :      799 words.
Constants           :      170 words.
Total program memory:      969 words.
Eeprom space        :        0 bytes.
Data segment        :        0 bytes.
Compilation completed, no errors.
Compilation ended 17.12.2023, 15:33:39
